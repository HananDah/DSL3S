[comment encoding = UTF-8 /]
[module animat('http://www.eclipse.org/uml2/3.0.0/UML')]
[import dsl3s::templates::services/]

[comment
Date: 15-06-2012    Author: Lu√≠s de Sousa
Skeleton of the Animat class. 
/]

[import dsl3s::templates::behavHarvest/]
[import dsl3s::templates::behavPerish/]
[import dsl3s::templates::behavReplicate/]
[import dsl3s::templates::behavMove/]

[template public animat(c : Class) ? (c.hasStereotype('Animat'))]
[comment @main /]
[file (c.name.concat('.java'), false, 'UTF-8')]

import java.util.HashMap;
import ec.util.MersenneTwisterFast;
import sim.engine.SimState;
import sim.engine.Steppable;
import sim.engine.Stoppable;
import sim.util.Bag;
import sim.util.geo.MasonGeometry;
import sim.util.geo.PointMoveTo;
import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Geometry;

public class [c.name/] extends MasonGeometry implements Steppable, Stoppable {

	protected Double wanderScope = 1.0;
 [if c.getTaggedValue(c, 'Animat', 'stop').isNotNull()]
 	protected Double stopGoal = new Double([c.getTaggedValue(c, 'Animat', 'stop')/]);
 [/if]

	public [c.name/](Geometry geom) 
	{
		super();
		this.geometry = geom;
		location = geom.getCentroid().getCoordinate();
	}
	
 [comment Iterate through linked States /]
 [for (ass:Association | c.getAssociations())]
  [for (s:Element | ass.relatedElement) ]
   [let sClass: Class = s.oclAsType(Class)]
   [if (sClass.isNotNull())]
    [if (sClass.hasStereotype('State'))]
	///////////////////////////////////////////////////////
    // State: [sClass.name/]
	
	//protected Double state[sClass.name/] = new Double([sClass.getTaggedValue(sClass, 'State', 'initValue')/]);
	protected static Double state[sClass.name/]Min = new Double([sClass.getTaggedValue(sClass, 'State', 'minValue')/]);
	protected static Double state[sClass.name/]Max = new Double([sClass.getTaggedValue(sClass, 'State', 'maxValue')/]);
	protected static Double state[sClass.name/]Var = new Double([sClass.getTaggedValue(sClass, 'State', 'stepVariation')/]);

	public Variable state[sClass.name/] = new Variable(
			new Double([sClass.getTaggedValue(sClass, 'State', 'initValue')/]), 
			state[sClass.name/]Min, 
			state[sClass.name/]Max);

	/*public Double getState[sClass.name/]() {return state[sClass.name/];}
    public void setState[sClass.name/](Double newState) {
		state[sClass.name/] = newState;
		if (state[sClass.name/] < state[sClass.name/]Min) 
			state[sClass.name/] = state[sClass.name/]Min;
		if (state[sClass.name/] > state[sClass.name/]Max) 
			state[sClass.name/] = state[sClass.name/]Max;
	}
	public Double harvestPercent[sClass.name/](Double percent, Double max) {
		Double harvested = state[sClass.name/] * percent / 100.0;
		if((max != null) && (harvested > max)) setState[sClass.name/](state[sClass.name/] - max);
		else setState[sClass.name/](state[sClass.name/] - harvested); 
		return harvested;
	}
	public Double harvestValue[sClass.name/](Double value, Double max) {
		Double harvested;
		if(value < state[sClass.name/]) harvested = value;
		else harvested = state[sClass.name/];
		if((max != null) && (harvested > max)) setState[sClass.name/](state[sClass.name/] - max);
		else setState[sClass.name/](state[sClass.name/] - harvested); 
		return harvested;
	}*/

	[comment Iterate through linked Replicate /]
	// Replicate constants
     [for (assR:Association | sClass.getAssociations())]
      [for (r:Element | assR.relatedElement) ]
	   [let rClass: Class = r.oclAsType(Class)]
       [if (rClass.isNotNull())]
        [if (rClass.hasStereotype('Replicate'))]
	     [if rClass.getTaggedValue(rClass, 'Replicate', 'upperThreshold').isNotNull()]
	protected static Double upperThresh[rClass.name/] = new Double([rClass.getTaggedValue(rClass, 'Replicate', 'upperThreshold')/]);
         [/if]
         [if rClass.getTaggedValue(rClass, 'Replicate', 'lowerThreshold').isNotNull()]
	protected static Double lowerThresh[rClass.name/] = new Double([rClass.getTaggedValue(rClass, 'Replicate', 'lowerThreshold')/]);
         [/if]
	     [if rClass.getTaggedValue(rClass, 'Replicate', 'toll').isNotNull()]
	protected static Double toll[rClass.name/] = new Double([rClass.getTaggedValue(rClass, 'Replicate', 'toll')/]);
         [/if]
	     [if rClass.getTaggedValue(rClass, 'Replicate', 'inheritance').isNotNull()]
	protected static Double inheritance[rClass.name/] = new Double([rClass.getTaggedValue(rClass, 'Replicate', 'inheritance')/]);
         [/if]
        [/if]
       [/if]
       [/let]
      [/for]	 
     [/for] [comment Replicate/]

	[comment Iterate through linked Perish /]
	// Perish thresholds
     [for (assP:Association | sClass.getAssociations())]
      [for (p:Element | assP.relatedElement) ]
	   [let pClass : Class = p.oclAsType(Class)]
       [if (pClass.isNotNull())]
        [if (pClass.hasStereotype('Perish'))]
	     [if pClass.getTaggedValue(pClass, 'Perish', 'upperThreshold').isNotNull()]
	protected static Double upperThresh[pClass.name/] = new Double([pClass.getTaggedValue(pClass, 'Perish', 'upperThreshold')/]);
         [/if]
         [if pClass.getTaggedValue(pClass, 'Perish', 'lowerThreshold').isNotNull()]
	protected static Double lowerThresh[pClass.name/] = new Double([pClass.getTaggedValue(pClass, 'Perish', 'lowerThreshold')/]);
         [/if]
        [/if]
       [/if]
      [/let]
      [/for]	 
     [/for] [comment Replicate/]

	[comment Iterate through linked Harvest /]
	// Harvest constants
     [for (assP:Association | sClass.getAssociations())]
      [for (p:Element | assP.relatedElement) ]
	   [let pClass : Class = p.oclAsType(Class)]
       [if (pClass.isNotNull())]
        [if (pClass.hasStereotype('Harvest'))]
		 [if (pClass.getTaggedValue(pClass, 'Harvest', 'harvested') <> sClass.name)]
	      [if (pClass.getTaggedValue(pClass, 'Harvest', 'percentHarvested').isNotNull())]  
 	protected static Double percent[pClass.name/] = new Double([pClass.getTaggedValue(pClass, 'Harvest', 'percentHarvested')/]);	
	      [/if]
	      [if (pClass.getTaggedValue(pClass, 'Harvest', 'valueHarvested').isNotNull())]
 	protected static Double value[pClass.name/] = new Double([pClass.getTaggedValue(pClass, 'Harvest', 'valueHarvested')/]);			
	      [/if]
		  [if (pClass.getTaggedValue(pClass, 'Harvest', 'maxImpact').isNotNull())]
 	protected static Double maxImpact[pClass.name/] = new Double([pClass.getTaggedValue(pClass, 'Harvest', 'maxImpact')/]);
		  [else]
	protected static Double maxImpact[pClass.name/] = null;	
		  [/if]		
 	protected static Double scope[pClass.name/] = new Double([pClass.getTaggedValue(pClass, 'Harvest', 'scope')/]);			
		 [/if]
        [/if]
       [/if]
      [/let]
      [/for]	 
     [/for] [comment Harvest/]

	///////////////////////////////////////////////////////
     [/if]
    [/if]
   [/let]
  [/for]	 
 [/for]  [comment States/]

	// Movement weights
 [for (ass:Association | c.getAssociations())]
  [for (p:Element | ass.relatedElement) ]
   [let pClass: Class = p.oclAsType(Class)]
    [if (pClass.isNotNull())]
     [if (pClass.hasStereotype('Move'))]
	protected static Double weight[pClass.name/] = new Double([pClass.getTaggedValue(pClass, 'Move', 'weight')/]);
    [comment Movement scope must be taken into account in the future/]
	protected static Double scope[pClass.name/] = 1.5[comment pClass.getTaggedValue(pClass, 'Move', 'scope')/];
     [/if]
    [/if]
   [/let]
  [/for]	 
 [/for]

	private Boolean stopped = false;
 	public Boolean Stopped() {return stopped;}
	private Stoppable stopper = null;
    public void setStopper(Stoppable stopper)   {this.stopper = stopper;}
    public void stop() {
    	stopped = true;
    	stopper.stop();
    }

	protected Coordinate location;
	public Coordinate getLocation() {return location;}

	public static Double getMinDisplayValue() {

		return new Double(
 [for (ass:Association | c.getAssociations())]
  [for (p:Element | ass.relatedElement) ]
   [let pClass: Class = p.oclAsType(Class)]
    [if (pClass.isNotNull())]
     [if (pClass.hasStereotype('State'))]
      [if (pClass.getTaggedValue(pClass, 'State', 'display') = 'true')]
		 	state[pClass.name/]Min +
      [/if]
     [/if]
    [/if]
   [/let]
  [/for]	 
 [/for]
			0); // this zero is an artifact of code generation
}

	public static Double getMaxDisplayValue() {

		return new Double(
 [for (ass:Association | c.getAssociations())]
  [for (p:Element | ass.relatedElement) ]
   [let pClass: Class = p.oclAsType(Class)]
    [if (pClass.isNotNull())]
     [if (pClass.hasStereotype('State'))]
      [if (pClass.getTaggedValue(pClass, 'State', 'display') = 'true')]
		 	state[pClass.name/]Max +
      [/if]
     [/if]
    [/if]
   [/let]
  [/for]	 
 [/for]
			0); // this zero is an artifact of code generation
}

	public Double getDisplayValue() {

		return new Double(
 [for (ass:Association | c.getAssociations())]
  [for (p:Element | ass.relatedElement) ]
   [let pClass: Class = p.oclAsType(Class)]
    [if (pClass.isNotNull())]
     [if (pClass.hasStereotype('State'))]
      [if (pClass.getTaggedValue(pClass, 'State', 'display') = 'true')]
		 	state[pClass.name/].getValue() +
      [/if]
     [/if]
    [/if]
   [/let]
  [/for]	 
 [/for]
			0); // this zero is an artifact of code generation
}


	//@Override
	public void step(SimState state) {

 [comment Get Simulation name /]
  [for (assS:Association | c.getAssociations())]
   [for (e:Element | assS.relatedElement) ]
	[let sim: Class = e.oclAsType(Class)]
	 [if (sim.isNotNull())]
	  [if (sim.hasStereotype('Simulation'))]
		[sim.name/] sim = ([sim.name/]) state;
	  [/if]
	 [/if]
    [/let]
   [/for]
  [/for]

		// Update state variables
 [for (ass:Association | c.getAssociations())]
  [for (p:Element | ass.relatedElement) ]
   [let pClass: Class = p.oclAsType(Class)]
    [if (pClass.isNotNull())]
     [if (pClass.hasStereotype('State'))]
		state[pClass.name/].add(state[pClass.name/]Var);
	 [/if]
    [/if]
   [/let]
  [/for]	 
 [/for]

[comment Iterate through linked States /]
[for (ass:Association | c.getAssociations())]
 [for (s:Element | ass.relatedElement) ]
  [let sClass: Class = s.oclAsType(Class)]
   [if (sClass.isNotNull())]
    [if (sClass.hasStereotype('State'))]
	 [if (sClass.hasLinkedStereotype('Harvest'))]
		harvest[sClass.name/](sim);
	 [/if]
   [/if]
  [/if]
 [/let]
 [/for]	 
[/for] [comment States /]

		perish(sim);
		
		replicate(sim);

 [if (c.hasLinkedStereotype('Move'))]
		move(sim);
 [/if]
	}

 [c.behavHarvest() /]

 [c.behavPerish() /]

 [c.behavMove() /]

 [c.behavReplicate() /]

	protected double randMove(double val, MersenneTwisterFast randGen) {
		return val + (randGen.nextDouble() - randGen.nextDouble()) * wanderScope;
	}

}

[/file]

[/template]