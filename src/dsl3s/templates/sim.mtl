[comment encoding = UTF-8 /]
[module sim('http://www.eclipse.org/uml2/3.0.0/UML')/]
[import dsl3s::templates::services/]
[comment
Date: 09-08-2012    Author: Lu√≠s de Sousa  (luis.a.de.sousa@gmail.com)
Generates the main Simulation class inheriting from SimState.
/]

[template public sim(c : Class) ? (c.hasStereotype('Simulation'))]

[file (c.name.concat('.java'), false, 'UTF-8')]
import sim.engine.SimState;
import sim.engine.Steppable;
import sim.engine.Stoppable;
import java.util.ArrayList;
import sim.util.geo.MasonGeometry;
import sim.field.geo.GeomVectorField;
import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Envelope;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;

public class [c.name/] extends SimState {

	//Simulation space
	public Integer spaceWidth = [c.getTaggedValue(c, 'Simulation', 'spaceWidth')/];
	public Integer spaceHeight = [c.getTaggedValue(c, 'Simulation', 'spaceHeight')/];

	GeometryFactory geomFactory = new GeometryFactory();
	Envelope globalMBR = new Envelope();

[for (assA:Association | c.getAssociations())]
 [for (a:Element | assA.relatedElement) ]
  [let aClass: Class = a.oclAsType(Class)] 
  [if (aClass.isNotNull())]
   [if (aClass.hasStereotype('Animat'))]
    [if (aClass.getTaggedValue(aClass, 'Animat', 'initNum').isNotNull())]

	public Integer initNum[aClass.name/] = [aClass.getTaggedValue(aClass, 'Animat', 'initNum')/];
	[/if]
	[comment if (aClass.getTaggedValue(aClass, 'Animat', 'inputFile').isNotNull()) /]
	//public String inputFile[comment aClass.name/] = "[comment aClass.getTaggedValue(aClass, 'Animat', 'inputFile')/]";
	[comment /if /]
	public GeomVectorField space[aClass.name/] = new GeomVectorField(spaceWidth, spaceHeight);

	protected ArrayList<MasonGeometry> garbage[aClass.name/] = new ArrayList<MasonGeometry>();
	public void addTo[aClass.name/]Garbage(MasonGeometry anim) {
		garbage[aClass.name/].add(anim);
	}
	protected void collect[aClass.name/]Garbage()  {
		for (MasonGeometry anim : garbage[aClass.name/]) {
			space[aClass.name/].removeGeometry(anim);
			((Stoppable) anim).stop();
		}
		garbage[aClass.name/] = new ArrayList<MasonGeometry>();
	}
   [/if]
   [if (aClass.hasStereotype('Environment'))]

	[if (aClass.getTaggedValue(aClass, 'Environment', 'inputFile').isNotNull())]
	//public String inputFile[aClass.name/] = "[aClass.getTaggedValue(aClass, 'Environment', 'inputFile')/]";
	[/if]
	public GeomVectorField space[aClass.name/] = new GeomVectorField(spaceWidth, spaceHeight);

   [/if]
  [/if]
  [/let]
 [/for]	 
[/for]

	// Lists for new animats
[for (assA:Association | c.getAssociations())]
 [for (a:Element | assA.relatedElement) ]
  [let aClass: Class = a.oclAsType(Class)] 
  [if (aClass.isNotNull())]
   [if (aClass.hasStereotype('Animat'))]
	protected ArrayList<[aClass.name/]> newAnimats[aClass.name/] = new ArrayList<[aClass.name/]>();
   [/if]
  [/if]
  [/let]
 [/for]	 
[/for]
	
	public Sim(long seed)
	{
		super(seed);
	}
	
	public void start()
	{
		super.start();

 [for (ass:Association | c.getAssociations())]
  [for (p:Property | ass.memberEnd) ]
   [if (p.class.isNotNull())]
    [if (p.class.hasStereotype('Environment'))]
     [if (p.class.getTaggedValue(p.class, 'Emerge', 'inputFile').isNotNull())]
		loadEnvironment(space[p.class.name/], inputFile[p.class.name/]);
     [else]
		init[p.class.name/]Objects();
	 [/if]
		globalMBR.expandToInclude(space[p.class.name/].getMBR());

    [/if]
   [/if]
  [/for]	 
 [/for]

		// At this stage animats are cast at random locations.
		// In the future this may be set with a spatial layer.
 [for (ass:Association | c.getAssociations())]
  [for (p:Property | ass.memberEnd) ]
   [if (p.class.isNotNull())]
    [if (p.class.hasStereotype('Animat'))]
		for(int i = 0; i < initNum[p.class.name/]; i++)
			init[p.class.name/](random.nextInt(spaceWidth), random.nextInt(spaceHeight));
	 [if (p.class.hasLinkedStereotype('Emerge'))]
		createEmerge[p.class.name/]();	
	 [/if]
		globalMBR.expandToInclude(space[p.class.name/].getMBR());

    [/if]
   [/if]
  [/for]	 
 [/for]
 [for (ass:Association | c.getAssociations())]
  [for (p:Property | ass.memberEnd) ]
   [if (p.class.isNotNull())]
    [if (p.class.hasStereotype('Environment'))]
		space[p.class.name/].setMBR(globalMBR);
    [/if]
	[if (p.class.hasStereotype('Animat'))]
		space[p.class.name/].setMBR(globalMBR);
    [/if]
   [/if]
  [/for]	 
 [/for]


		schedule.scheduleRepeating(schedule.EPOCH, 1, new Steppable()
		{
			public void step(SimState state) { 

 [for (ass:Association | c.getAssociations())]
  [for (p:Property | ass.memberEnd) ]
   [if (p.class.isNotNull())]
    [if (p.class.hasStereotype('Animat'))]
				collect[p.class.name/]Garbage();
				castNew[p.class.name/]();
    [/if]
   [/if]
  [/for]	 
 [/for]
			}
		});
	}

	/**
	 * Here don't forget about expanding the MBR
     */
	protected void loadEnvironment(GeomVectorField space, String file)
	{
		
	}

	public void siteObject(GeomVectorField space, MasonGeometry geom, double x, double y) {
		
		Coordinate coord = new Coordinate(new Double(x), new Double(y));
		geom.geometry = geomFactory.createPoint(coord);
		space.addGeometry(geom);
	}

 [for (ass:Association | c.getAssociations())]
  [for (p:Element | ass.relatedElement) ]
   [let pClass: Class = p.oclAsType(Class)]
    [if (pClass.isNotNull())]
     [if (pClass.hasStereotype('Environment'))]
	public void init[pClass.name/]Objects() {

		for (int i=0; i < spaceWidth; i++)
			for (int j=0; j < spaceHeight; j++)
			{
				Coordinate coord = new Coordinate(new Double(i), new Double(j));
				Geometry geom = geomFactory.createPoint(coord);
			  [if (pClass.getTaggedValue(pClass, 'Environment', 'initRandom') = 'true')]
				[pClass.name/] obj = new [pClass.name/](random, geom);
			  [else]
				[pClass.name/] obj = new [pClass.name/](geom);
			  [/if]
				obj.setStopper(schedule.scheduleRepeating(obj));
				space[pClass.name/].addGeometry(obj);
			}
	}
     [/if]
    [/if]
   [/let]
  [/for]	 
 [/for]

 [for (ass:Association | c.getAssociations())]
  [for (p:Property | ass.memberEnd) ]
   [if (p.class.isNotNull())]
    [if (p.class.hasStereotype('Animat'))]
	protected [p.class.name/] generate[p.class.name/](double x, double y)
	{
		Coordinate coord = new Coordinate(new Double(x), new Double(y));
		Geometry geom = geomFactory.createPoint(coord);
		[p.class.name/] new[p.class.name/] = new [p.class.name/](geom);
		new[p.class.name/].setStopper(schedule.scheduleRepeating(new[p.class.name/]));
		return new[p.class.name/];
	}

	protected void init[p.class.name/](double x, double y) 
	{
		[p.class.name/] new[p.class.name/] = generate[p.class.name/](x, y);
		space[p.class.name/].addGeometry(new[p.class.name/]);
	}

	public [p.class.name/] create[p.class.name/](double x, double y) 
	{
		[p.class.name/] new[p.class.name/] = generate[p.class.name/](x, y);
		newAnimats[p.class.name/].add(new[p.class.name/]);
		return new[p.class.name/];
	}

	protected void castNew[p.class.name/] () 
	{	
		for(int i = 0; i < newAnimats[p.class.name/].size(); i++) 
		{
			[p.class.name/] new[p.class.name/] = newAnimats[p.class.name/].get(i);
			space[p.class.name/].addGeometry(new[p.class.name/]);
		}
		newAnimats[p.class.name/] = new ArrayList<[p.class.name/]>();
	}

	 [if (p.class.hasLinkedStereotype('Emerge'))]
	public void createEmerge[p.class.name/]() {
		[p.class.name/]Emerge emerge = new [p.class.name/]Emerge();
		emerge.setStopper(schedule.scheduleRepeating(emerge));
	}
	 [/if]

    [/if]
   [/if]
  [/for]	 
 [/for]

}
[/file]
[/template]