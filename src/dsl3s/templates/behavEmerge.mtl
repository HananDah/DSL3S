[comment encoding = UTF-8 /]
[module behavEmerge('http://www.eclipse.org/uml2/3.0.0/UML')]
[import dsl3s::templates::services/]

[comment
Date: 22-09-2012    Author: Lu√≠s de Sousa
Generates the Emerge class for an Animat.
/]

[template public behavEmerge(c : Class) ? (c.hasStereotype('Animat'))]

[if (c.hasLinkedStereotype('Emerge'))]
[file (c.name.concat('Emerge.java'), false, 'UTF-8')]
import sim.engine.SimState;
import sim.engine.Steppable;
import sim.engine.Stoppable;
import sim.util.Bag;
import sim.util.IntBag;
import sim.field.geo.GeomVectorField;

public class [c.name/]Emerge implements Steppable, Stoppable {
		
[comment Iterate through linked Emerge /]
[for (assE:Association | c.getAssociations())]
 [for (e:Element | assE.relatedElement) ]
 [let eClass: Class = e.oclAsType(Class)] 
  [if (eClass.isNotNull())]
   [if (eClass.hasStereotype('Emerge'))]
    [if (eClass.getTaggedValue(eClass, 'Emerge', 'probability').isNotNull())]
	private static Double prob[eClass.name/] = new Double([eClass.getTaggedValue(eClass, 'Emerge', 'probability')/]);
    [/if]
	[if (eClass.getTaggedValue(eClass, 'Emerge', 'upperThreshold').isNotNull())]
	private static Double upperThresh[eClass.name/] = new Double([eClass.getTaggedValue(eClass, 'Emerge', 'upperThreshold')/]);
	[/if]
	[if (eClass.getTaggedValue(eClass, 'Emerge', 'lowerThreshold').isNotNull())]
	private static Double lowerThresh[eClass.name/] = new Double([eClass.getTaggedValue(eClass, 'Emerge', 'lowerThreshold')/]);
	[/if]
   [/if]
  [/if]
 [/let]
 [/for]	 
[/for] [comment Emerge /]

	public [c.name/]Emerge() {}
	
	private Stoppable stopper = null;
    public void setStopper(Stoppable stopper) {this.stopper = stopper;}

	//@Override
	public void stop() {
		// TODO Auto-generated method stub
		stopper.stop();
	}

	//@Override
	public void step(SimState state) {

		Sim sim = (Sim) state;
		Double scope;

		[comment Assumes a discretisation of space /]
		for(int x = 0; x < sim.spaceWidth; x++)
			for(int y = 0; y < sim.spaceHeight; y++) {
[comment Iterate through linked Emerge /]
[for (assE:Association | c.getAssociations())]
 [for (e:Element | assE.relatedElement) ]
 [let eClass: Class = e.oclAsType(Class)] 
  [if (eClass.isNotNull())]
   [if (eClass.hasStereotype('Emerge'))]
				double weight[eClass.name/] = 0;
   [/if]
  [/if]
 [/let]
 [/for]	 
[/for] [comment Emerge /]
				IntBag xPos = null, yPos = null;
				Bag neigh;

				if (!isOccupied(sim.space[c.name/])) {
[comment Iterate through linked Emerges /]
[for (assE:Association | c.getAssociations())]
 [for (e:Element | assE.relatedElement) ]
 [let eClass: Class = e.oclAsType(Class)] 
  [if (eClass.isNotNull())]
   [if (eClass.hasStereotype('Emerge'))]
	[comment Iterate through linked States and Environments/]
    [for (assS:Association | eClass.getAssociations())]
     [for (s:Element | assS.relatedElement) ]
     [let sClass: Class = s.oclAsType(Class)]
      [if (sClass.isNotNull())]
	   [comment Linked States /]
       [if (sClass.hasStereotype('State'))]
		[comment Iterate through linked Animats /]
    	[for (assA:Association | sClass.getAssociations())]
     	 [for (a:Element | assA.relatedElement) ]
     	 [let aClass: Class = a.oclAsType(Class)]
      	  [if (aClass.isNotNull())]
           [if (aClass.hasStereotype('Animat'))]

					scope = new Double([eClass.getTaggedValue(eClass, 'Emerge', 'scope')/]);
					Bag neigh[aClass.name/] = sim.space[aClass.name/].getObjectsWithinDistance(this, scope);

					for (Object obj : neigh) 
					{
			[if (eClass.getTaggedValue(eClass, 'Emerge', 'probability').isNotNull())]
						weight[eClass.name/] = 
							(((([aClass.name/]) obj).getState[sClass.name/]() - [aClass.name/].state[sClass.name/]Min + 0.0) /
							 ([aClass.name/].state[sClass.name/]Max - [aClass.name/].state[sClass.name/]Min + 0.0)) *
							prob[eClass.name/];
			[/if]
			[if (eClass.getTaggedValue(eClass, 'Emerge', 'upperThreshold').isNotNull())]
						weight[eClass.name/] += (([aClass.name/]) obj).getState[sClass.name/]();
			[/if]
					}

           [/if]
	      [/if]
	     [/let]
	     [/for]	 
	    [/for] [comment Animats /]
	   [/if] [comment States /]
	   [if (sClass.hasStereotype('Environment'))]
					scope = new Double([eClass.getTaggedValue(eClass, 'Emerge', 'scope')/]);
					Bag neigh[sClass.name/] = sim.space[sClass.name/].getObjectsWithinDistance(this, scope);

					for (Object obj : neigh) 
					{
			[if (eClass.getTaggedValue(eClass, 'Emerge', 'probability').isNotNull())]
						weight[eClass.name/] = 
							(((([sClass.name/]) obj).getValue() - [sClass.name/].valueMin + 0.0) /
							 ([sClass.name/].valueMax - [sClass.name/].valueMin + 0.0)) *
							prob[eClass.name/];
			[/if]
			[if (eClass.getTaggedValue(eClass, 'Emerge', 'upperThreshold').isNotNull())]
						weight[eClass.name/] += (([sClass.name/]) obj).getValue();
			[/if]
					}
       [/if]
	  [/if]
	 [/let]
	 [/for]	 
	[/for] [comment States /]

	[if (eClass.getTaggedValue(eClass, 'Emerge', 'upperThreshold').isNotNull())]
	 [if (eClass.getTaggedValue(eClass, 'Emerge', 'lowerThreshold').isNotNull())]
					if((weight[eClass.name/] <= upperThresh[eClass.name/]) &&
					   (weight[eClass.name/] >= lowerThresh[eClass.name/]) )
						weight[eClass.name/] = 101;
					else weight[eClass.name/] = -1;
	 [/if]
	[/if]

   [/if]
  [/if]
 [/let]
 [/for]	 
[/for] [comment Emerges /]		
					if(
[comment Iterate through linked Emerge /]
[for (assE:Association | c.getAssociations())]
 [for (e:Element | assE.relatedElement) ]
 [let eClass: Class = e.oclAsType(Class)] 
  [if (eClass.isNotNull())]
   [if (eClass.hasStereotype('Emerge'))]
	[if (eClass.getTaggedValue(eClass, 'Emerge', 'required') = 'true')]
				 	(weight[eClass.name/] > 0) && 
    [/if]
   [/if]
  [/if]
 [/let]
 [/for]	 
[/for] [comment Emerge /]	
				 	((
[comment Iterate through linked Emerge /]
[for (assE:Association | c.getAssociations())]
 [for (e:Element | assE.relatedElement) ]
 [let eClass: Class = e.oclAsType(Class)] 
  [if (eClass.isNotNull())]
   [if (eClass.hasStereotype('Emerge'))]
				  	  weight[eClass.name/] + 
   [/if]
  [/if]
 [/let]
 [/for]	 
[/for] [comment Emerge /]	
				  	  0) > sim.random.nextInt(101)))			
						sim.create[c.name/](x, y);
			}	
		}
	}

	protected Boolean isOccupied(GeomVectorField space)  {
		Bag local = space.getCoveringObjects(this);
		local.addAll(space.getCoveredObjects(this); 
		if (local.numObjects > 0) return true;
		return false;
	}	
}
[/file]
[/if]
[/template]